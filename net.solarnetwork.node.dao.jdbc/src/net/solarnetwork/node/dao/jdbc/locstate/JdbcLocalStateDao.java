/* ==================================================================
 * JdbcLocalStateDao.java - 14/04/2025 11:35:41â€¯am
 *
 * Copyright 2025 SolarNetwork.net Dev Team
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307 USA
 * ==================================================================
 */

package net.solarnetwork.node.dao.jdbc.locstate;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import org.springframework.jdbc.core.ConnectionCallback;
import net.solarnetwork.node.dao.LocalStateDao;
import net.solarnetwork.node.dao.jdbc.BaseJdbcGenericDao;
import net.solarnetwork.node.domain.LocalState;
import net.solarnetwork.node.domain.SecurityToken;
import net.solarnetwork.settings.SettingSpecifier;
import net.solarnetwork.settings.SettingSpecifierProvider;
import net.solarnetwork.settings.support.BasicTitleSettingSpecifier;

/**
 * JDBC implementation of {@link LocalStateDao}.
 *
 * @author matt
 * @version 1.0
 * @since 3.4
 */
public class JdbcLocalStateDao extends BaseJdbcGenericDao<LocalState, String>
		implements LocalStateDao, SettingSpecifierProvider {

	/** The table name for {@link SecurityToken} entities. */
	public static final String TABLE_NAME = "locstate";

	/** The charge point table version. */
	public static final int VERSION = 1;

	/**
	 * Enumeration of SQL resources.
	 */
	public enum SqlResource {

		/** Compare and save. */
		CompareAndSave("compare-and-save"),

		/** Compare and change. */
		CompareAndChange("compare-and-change"),

		/** Save and return previous value. */
		GetAndSave("get-and-save"),

		/** Get a count of stored records. */
		Count("count"),

		;

		private final String resource;

		private SqlResource(String resource) {
			this.resource = resource;
		}

		/**
		 * Get the SQL resource name.
		 *
		 * @return the resource
		 */
		public String getResource() {
			return resource;
		}
	}

	/**
	 * Constructor.
	 */
	public JdbcLocalStateDao() {
		super(LocalState.class, String.class, LocalStateRowMapper.INSTANCE, "sn_%s", TABLE_NAME,
				VERSION);
		setUseAutogeneratedKeys(false);
	}

	@Override
	public String getSettingUid() {
		return "net.solarnetwork.node.dao.jdbc.locstate";
	}

	@Override
	public String getDisplayName() {
		return "LocalStateDao (JDBC)";
	}

	@Override
	public List<SettingSpecifier> getSettingSpecifiers() {
		return Collections.singletonList((SettingSpecifier) new BasicTitleSettingSpecifier("status",
				getStatusMessage(), true, true));
	}

	private String getStatusMessage() {
		long rowCount = 0;
		try {
			rowCount = rowCount();
		} catch ( Exception e ) {
			log.warn("Error finding Local State row count.", e);
		}
		return getMessageSource().getMessage("status.msg", new Object[] { rowCount },
				Locale.getDefault());
	}

	private long rowCount() {
		final Number rowCountNum = getJdbcTemplate()
				.queryForObject(getSqlResource(SqlResource.Count.getResource()), Number.class);
		return (rowCountNum == null ? 0 : rowCountNum.longValue());
	}

	@Override
	protected void setUpdateStatementValues(LocalState obj, PreparedStatement ps) throws SQLException {
		Instant cre = obj.getCreated() != null ? obj.getCreated() : Instant.now();
		Instant mod = obj.getModified() != null ? obj.getModified()
				: obj.getCreated() == null ? cre : Instant.now();
		ps.setString(1, obj.getId());
		setInstantParameter(ps, 2, cre);
		setInstantParameter(ps, 3, mod);
		ps.setString(4, String.valueOf(obj.getType().getKey()));
		ps.setBytes(5, obj.getData());
	}

	@Override
	public LocalState compareAndSave(LocalState entity, Object expectedValue) {
		return getJdbcTemplate().execute((ConnectionCallback<LocalState>) conn -> {
			LocalState copy = copyState(entity);
			PreparedStatement stmt = conn
					.prepareStatement(getSqlResource(SqlResource.CompareAndSave.getResource()));
			setUpdateStatementValues(copy, stmt);
			stmt.setBytes(6, entity.getType().encode(expectedValue));

			if ( stmt.execute() ) {
				try (ResultSet rs = stmt.getResultSet()) {
					if ( rs.next() ) {
						LocalState result = getRowMapper().mapRow(stmt.getResultSet(), 1);
						if ( Objects.equals(copy.getModified(), result.getModified()) ) {
							postEntityEvent(result.getId(), entity, EntityEventType.STORED);
						}
						return result;
					}
				}
			}
			return entity;
		});
	}

	@Override
	public LocalState compareAndChange(LocalState entity) {
		return getJdbcTemplate().execute((ConnectionCallback<LocalState>) conn -> {
			LocalState copy = copyState(entity);
			PreparedStatement stmt = conn
					.prepareStatement(getSqlResource(SqlResource.CompareAndChange.getResource()));
			setUpdateStatementValues(copy, stmt);

			if ( stmt.execute() ) {
				try (ResultSet rs = stmt.getResultSet()) {
					if ( rs.next() ) {
						LocalState result = getRowMapper().mapRow(stmt.getResultSet(), 1);
						if ( Objects.equals(copy.getModified(), result.getModified()) ) {
							postEntityEvent(result.getId(), entity, EntityEventType.STORED);
						}
						return result;
					}
				}
			}
			return entity;
		});
	}

	private static LocalState copyState(LocalState entity) {
		LocalState copy;
		if ( entity.getCreated() == null ) {
			copy = new LocalState(entity.getId(), Instant.now().truncatedTo(ChronoUnit.MILLIS),
					entity.getType(), null);
			copy.setData(entity.getData());
			copy.setModified(copy.getCreated());
		} else {
			copy = entity.clone();
			copy.setModified(Instant.now().truncatedTo(ChronoUnit.MILLIS));
		}
		return copy;
	}

	@Override
	public LocalState getAndSave(LocalState entity) {
		return getJdbcTemplate().execute((ConnectionCallback<LocalState>) conn -> {
			PreparedStatement stmt = conn
					.prepareStatement(getSqlResource(SqlResource.GetAndSave.getResource()));
			setUpdateStatementValues(entity, stmt);

			if ( stmt.execute() ) {
				try (ResultSet rs = stmt.getResultSet()) {
					if ( rs.next() ) {
						LocalState result = getRowMapper().mapRow(stmt.getResultSet(), 1);
						if ( result.differsFrom(entity) ) {
							postEntityEvent(result.getId(), entity, EntityEventType.STORED);
						}
						return result;
					}
				}
			}
			postEntityEvent(entity.getId(), entity, EntityEventType.STORED);
			return null;
		});
	}

}
